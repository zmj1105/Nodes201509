<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script type="text/javascript">
    //1、i++ / ++i 的区别?
    //两者都是在自身的基础上累加1，但是在和其他的值进行运算的时候，顺序是不一样的
    //n+(i++) ->先n+i算出结果，完成后i在+1
    //n+(++i) ->先i+1，把累加后的i的值在和n进行计算

    //var i = 10;
    //    console.log(10 + (i++));//->20  10+10=20->i=10+1=11
    //    console.log(i);//->11
    //    console.log(10 + (++i));//->21  i=10+1=11->10+11=21
    //    console.log(i);//->11
    //console.log(10 + (++i) + (i++) + (++i) + (i++));//->58
    //10+(++i) ->i=11 10+11=21
    //21+(i++) ->21+11=32 i=12
    //32+(++i) ->i=13 32+13=45
    //45+(i++) ->45+13=58 i=14
    //console.log(i);//->14

    //2、JS内存释放问题
    //[堆内存] ->存储引用数据类型值的
    //不销毁：开辟一个堆内存,同时浏览器为其分配了一个地址,如果有变量存储了这个地址,我们就说当前的变量把这个堆内存给占用了,一但被占用就不能销毁了
    //销毁：当我们的堆内存已经没有变量占用了，浏览器会在空闲的时候把它释放掉 ->"JS中浏览器的垃圾回收机制"
    //    var obj = {name: "珠峰"};
    //    var objTwo = obj;
    //    //想让堆内存释放->"JS性能的优化":把没有用的堆内存释放掉
    //    obj = null;
    //    objTwo = null;

    //    function fn(){}
    //    fn=null;

    //[栈内存] ->作用域,用来执行JS代码的
    //全局作用域window ->当浏览器加载页面的时候形成全局的作用域，只有当前HTML页面关闭的时候全局作用域才销毁,只要当前页面不关闭,我们的全局作用域就不销毁("不销毁的作用域")->说明了在里面定义的全局变量的值也是不销毁的

    //私有作用域 ->函数执行的时候形成一个新的私有的作用域(形参赋值->预解释->代码执行)，当代码执行完后后，一般情况下，新形成的私有的作用域自己就销毁了，下一次在执行又是从新开辟一个新的私有的作用域，这样做的目的是浏览器自己进行性能优化的操作，使浏览器不会因为过多的内存而卡死 ->每一次执行函数之间是没有任何的关系的,例如：第一次执行fn和第二次执行fn是没有任何的关系的
    //    function fn() {
    //        var total = null;
    //        total += 100;
    //    }
    //    fn();
    //    fn();
    //    fn();

    //私有作用域"不销毁"的情况->函数执行形成一个私有的作用域(A),在A中有一部分内容被A以外的变量给占用了，那么当前的这个私有的作用域A就不能销毁了，例如：
    //    function fn() {
    //        var total = 100;
    //        return function () {
    //
    //        };//->return xxxfff111;
    //    }
    //    var f = fn();//->f=xxxfff111; f占用了私有作用域A中的那个堆内存，那么A这个私有的作用域就不能销毁了 ->A中存储的私有变量total的值也不在销毁了...

    //不立即销毁
    //    function fn() {
    //        var total = 100;
    //        return function () {
    //
    //        }
    //    }
    //    //fn();//->这样执行完成后，虽然也返回了一个堆内存的地址，但是由于外面没有变量占用这个地址，所以形成的私有的作用域A也是销毁的
    //    fn()();//->执行fn返回一个地址xxxfff111，这个地址对应了一个小的函数，然后我们在紧接着让这个小的函数执行
</script>
</body>
</html>