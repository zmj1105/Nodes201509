<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script type="text/javascript">
    //同步:张万强下课回家，煮咖啡，需要1个小时才可以煮好，在一个小时之内，什么都不干就干盯着等，等咖啡煮好了，然后在去看书->当前这件事情没有完成，则不进行下面的事情
    //在JS中一般情况下都是同步,拿下面这个例子来说,只有当1百万次循环完成后才会执行ok
    //    for (var i = 0; i < 1000000; i++) {
    //        i === 999999 ? console.log(i) : null;//->999999(1)
    //    }
    //    console.log("ok");//->"ok"(2)

    //异步:张万强下课回家，煮咖啡，需要1个小时才可以煮好，在一个小时之内，不干等着，首先去看书->当前这件事情没有完成，但是在这个段时间内，继续执行下面的事情
    //1)JS中的定时器是异步编程的
    //    var count = 0;
    //    window.setTimeout(function () {
    //        count++;
    //        console.log(count);//->1 (2)
    //    }, 1000);//->设置一个定时器,但是1000ms才会执行对应的方法,在这个时间内,我们继续执行下面的代码,只有当下面的代码执行完成后,才会返回头看时间到了吗,到了的话执行,没到继续等着
    //    console.log(count);//->0 (1)

    //    var count = 0;
    //    window.setTimeout(function () {
    //        count++;
    //        console.log(count);//->1 (2)
    //    }, 0);//->在定时器中,我们的等待时间写0也不是立即执行,每一个浏览器有一个默认的最小等到时间,谷歌5~6ms IE10~13ms
    //    console.log(count);//->0 (1)

    //    var count = 0;
    //    window.setTimeout(function () {
    //        count++;
    //        console.log(count);//->1 (2)
    //    }, 5);
    //    for (var i = 0; i < 100000000; i++) {
    //        //在5ms内循环肯定完成不了,假设需要1s中才能完成,但是我们也是先把循环和下面的代码执行完成后在看定时器是否到时间->我们给定时器设置一个时间,不一定到时间就执行,只有下面的代码都执行完成后(可能超过设置的时间,也可能小于设置的时间),才会返回头看定时器
    //    }
    //    console.log("ok");//->"ok" (1)

    //2)在JS中所有的事件绑定都是异步编程的
    //oLis.length->3
    for(var i=0;i<oLis.length;i++){
        oLis[i].onclick=function(){
            alert(i);
        };
    }
    //弹出的i的值都是3
    //当i==0的时候,给第一个li绑定了点击事件,但是距离我手动的点击还有一段时间,在这段时间内,继续执行下一次循环->异步编程
</script>
</body>
</html>