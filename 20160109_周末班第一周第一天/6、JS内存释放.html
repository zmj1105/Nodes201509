<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
</head>
<body>
<script type="text/javascript">
    //1、堆内存的释放:
    //对于谷歌浏览器来说,浏览器会每隔一段时间查看所有的内存,如果当前的内存被其他的变量等东西占用了，那么是不能释放的；但是一旦没有被占用，浏览器会把这些垃圾内存进行自动的释放销毁；
    //var obj = {num: 13};//->xxxfff000 此时被obj占用这个,当前的这个堆内存不能释放
    //obj = null;//->null空对象指针,也就是obj不指向任何一个空间,之前的那个堆内存就没有被占用了,浏览器在空闲的时候就会把它销毁
    //IE和火狐浏览器的原理和谷歌差不多，但是也有不一样的地方，回去后自己查看“JS高级程序设计第三版”最后几章进行自己扩展

    //2、栈内存的释放
    //全局作用域:当浏览器加载HTML页面的时候形成，只有当前HTML页面关闭的时候才会销毁；->全局作用域是不销毁的作用域,同时它里面的全局变量的值也不会销毁

    //私有作用域:当函数执行的时候会产生一个新的私有的作用域
    //1)立即销毁
    //一个函数可以执行多次,每一次执行都会形成一个新的私有作用域(形参赋值-预解释-JS代码执行...)，每一次执行之间互不影响;
    //一般情况下,当函数执行完成后，浏览器为了优化本身的性能，刚开始形成的那个私有的作用域会自行释放销毁掉;
    //    function fn() {}
    //    fn();
    //    fn();
    //    fn();

    //2)不销毁
    //当一个私有作用域中的内容被作用域以外的变量等其他的东西占用了，那么当前的这个私有的作用域就不能在销毁了，里面的私有的变量的值也不在销毁了
    //    function fn() {
    //        var num = 10;
    //        return function () {
    //            num++;
    //            console.log(num);
    //        }
    //    }
    //    var f = fn();
    //    f();//->11
    //    f();//->12
    //    f();//->13

    //3)不立即销毁
    //当第一次执行fn返回一个xxxfff111,虽然没有被外面直接的占用,但是紧接着要执行一次,所以此时的xxxfff111临时不能销毁,同理对应的作用域A暂时也不能销毁
    //当xxxfff111执行完成后，都销毁了
    //    function fn() {
    //        var num = 10;
    //        return function () {
    //            num++;
    //            console.log(num);
    //        }
    //    }
    //    fn()();//->先执行fn,然后把fn执行的返回值xxxfff111紧接着在执行
</script>
</body>
</html>